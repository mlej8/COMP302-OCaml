Why OCaml ? 

Imperative programming language 
- Deals with objects, everything is an object.
- Command driven (a lot of commands i.e. setSpeed(), doSomething(), etc.)

Functional programming language
- Everything is an expression that is being evaluated.
- Everything in functional programming is boiled down to a value. This makes things much more efficient, the computer doesn't have to understand what does a Car Object means, because everthing is boiled down to a specific value.
- Support for recursion
- Support for Pattern matching 

Functional programming is a new way of considering programming and problem solving.

In OCaml, we don't have to use a return keyword, we simply write the return value in the body of the expression. 

In pattern matching, _ means any other pattern. 

Every if conditional statement must have then and an else 

cons :: is a list constructor and prepends an element to the beginning of a list

list must have consistent types (all elements of the same lists have same type)

In OCaml, it is possible to trace a function using #trace function_name;; to trace the input and the output of a function. Use #untrace function_name to untrace. 

Recursive functions avoid any mutation of any variables (i.e. when  you loop, you modify the value of the index i). We are trying to stay away from mutable variable. 


Call-Stacks
This stack contains all the function calls that have started but not yet returned. calling a function f pushes an instance of f on the stack. When a call to f finishes, it is popped from the stack.
These stack-frames store information like the value of local variables and "what is left to do" in the function. 
Due to recursion, multiple stack-frames may be calls to the same function. 

Optimization
The compiler recognizees that it is unnecessary to keep around a stack-frame if all it does is taking a callee's result and return it
ML recognizes the tail calls in the compiler and treats them differently:
- It removes the caller's stack-frame before it makes the call, allowing the callee to reuse the same stack space that the caller was using
- As efficient as a loop in other languages